plugin "regexExpander"

global { global.padding = 10 }


Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.darkgray = rgba(0.6, 0.6, 0.6, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.sky = rgba(0.42, 0.65, 0.77, 1.0)
    Colors.lightsky = rgba(0.252, 0.65, 0.77, 0.25)
    Colors.pink = rgba(0.78, 0.256, 0.53, 1.0)
    Colors.lightpink = rgba(0.78, 0.256, 0.53, 0.25)
    Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

Scene s {
    -- optimized fields to be shared with diffuse obj
    s.x = OPTIMIZED
    s.y = OPTIMIZED
    s.sizeX = OPTIMIZED
    s.sizeY = OPTIMIZED

    s.container = Rectangle {
        x = s.x
        y = s.y
        sizeX = s.sizeX
        sizeY = s.sizeY
        fill  = Colors.none
        strokeColor = Colors.blue
        strokeWidth = 1.5
    }
}

DiffuseObject d
where InOS(d, s) with Scene s {
    d.room = Rectangle {
        angle  = 0
        fill   = Colors.none
        strokeColor = Colors.black
        strokeWidth = 1.5
        -- optimize height, width, location
        x = s.x
        y = s.y
        sizeX = s.sizeX
        sizeY = s.sizeY
    }
    d.containFn = ensure contains(s.container, d.room)
    d.layering  = d.room below s.container
}


-- No "in path" predicate because scene geometry shouldn't depend directly on a path
SpecularObject o
where InOS(o, s) with Scene s {
	-- create mirror shape and put it in scene
    -- TODO: import SVG?
    o.shape = Rectangle {
        fill = Colors.gray
        sizeX = 100.0
        sizeY = 30.0
    }
    o.containFn = ensure contains(s.container, o.shape)
    o.layering  = o.shape above s.container
}


---------------------------NON-COMPILABLE CODE----------------------------------

/*
LightSource L -- subtyped
where In(L, S) with Scene S {
	    -- draw L in S
	    -- has to have a location
} -- Same with camera

Path p; PathSample ps
where In(p, S) with Scene S {
      -- make path sample color
      -- label path with its string
}

-- Path vertex with various kinds of bounces

PathVertex v; PathSample ps
where InVP(v, p) with Path p {
     -- v.location = (?, ?)
}

-- TODO: work out the pathsample???

PathVertex v; PathSample ps
where InVP(v, p); OnLight(v)
with Path p; LightSource L {
	-- put the location on L's border
} -- same with eye, but going into the eye

PathVertex v; PathSample ps
where InVP(v, p); Hits(v, o)
with Path p; SpecularObject o {
          -- on border of mirror
}
-- Rays

PathEdge e; PathSample ps
where InVE(v1, e); InVE(v2, e);
with PathVertex v1, v2 {
     -- draw an arrow from v1's location to v2's location
}

PathEdge e; SceneGeometry o; PathSample ps {
	 -- ray should not intersect scene geometry
}

-- Do something at bounce point

-- Two edges that share a vertex
PathEdge e1; PathEdge e2; PathSample ps
where InVE(v1, e1); InVE(v2, e1); InVE(v2, e2); InVE(v3, e2);
      Hits(v2, o)
with PathVertex v1, v2, v3;
     SceneGeometry o {
     -- draw bounce normal for all bounces
}

-- Do something at specular bounce point

PathEdge e1; PathEdge e2; PathSample ps
where InVE(v1, e1); InVE(v2, e1); InVE(v2, e2); InVE(v3, e2);
       IsSpecular(v2);
       Hits(v2, o)
with PathVertex v1, v2, v3;
     SceneGeometry o {
     -- make sure angles are equal
}
*/
