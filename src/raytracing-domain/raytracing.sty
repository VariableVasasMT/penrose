-- plugin "raytracing"

global { global.padding = 10 }


Colors {
    Colors.black = rgba(0.0, 0.0, 0.0, 1.0)
    Colors.gray = rgba(0.8, 0.8, 0.8, 1.0)
    Colors.darkgray = rgba(0.6, 0.6, 0.6, 1.0)
    Colors.red = rgba(1.0, 0.0, 0.0, 1.0)
    Colors.yellow = rgba(1.0, 1.0, 0.0, 1.0)
    Colors.orange = rgba(1.0, 0.6, 0.0, 1.0)
    Colors.lightorange = rgba(1.0, 0.6, 0.0, 0.25)
    Colors.green = rgba(0.0, 1.0, 0.0, 1.0)
    Colors.blue = rgba(0.0, 0.0, 1.0, 1.0)
    Colors.lightblue = rgba(0.0, 0.0, 1.0, 0.25)
    Colors.cyan = rgba(0.0, 1.0, 1.0, 1.0)
    Colors.purple = rgba(0.5, 0.0, 0.5, 1.0)
    Colors.white = rgba(1.0, 1.0, 1.0, 1.0)
    Colors.none = rgba(0.0, 0.0, 0.0, 0.0)
    Colors.sky = rgba(0.42, 0.65, 0.77, 1.0)
    Colors.lightsky = rgba(0.252, 0.65, 0.77, 0.25)
    Colors.pink = rgba(0.78, 0.256, 0.53, 1.0)
    Colors.lightpink = rgba(0.78, 0.256, 0.53, 0.25)
    Colors.bluegreen = rgba(0.44, 0.68, 0.60, 1.0)
}

Scene d {
    d.room = Rectangle {
        angle  = 0
        fill   = Colors.none
        strokeColor = Colors.black
        strokeWidth = 1.5
        -- optimize height, width, location
        sizeX = OPTIMIZED
        sizeY = OPTIMIZED
        x = OPTIMIZED
        y = OPTIMIZED
    }
}

---------------------------NON-COMPILABLE CODE----------------------------------

/*
-- There is only one light source GPI and camera GPI for the whole Substance program
LightSource X; Diagram d {
    -- white border so arrows look rooted at center
    -- create one boundary point per sample?
    X.shape = Circle {
         border-color = "white"
         border-width = 10
         layering = "top"
         -- optimize radius, location
    }

    X.location = X.shape.center
    X.inFn = ensure in(X.shape, d.room)
}

Camera X {
    X.shape = Image {
        path = "raytracing/eye.svg"
        -- optimize angle, size, location
    }

    -- TODO: construct lens inline?
    X.location = findLens(X.shape, global.padding)
    X.inFn = ensure in(X.shape, d.room)
}

-- Give the visual semantics of "sample," meaning "make another path" (possibly w/ different rand seed) using a nested selector
Path p; PathType T; Diagram d
where p = sample(T) {
    p.color = random(Colors.ColorType)

    -- There is one anchor point created for *every* occurrence of D or S in a path type
    -- They are created independently for each sample
    -- Each occurrence of an element x in a list L is uniquely denoted/named by its index: L[i]
    DiffuseBounce D
    where InList(D, T) {
        p.D.shape = d.shape
        -- later used to calculate normals
        p.D.location = (optimized, optimized)
        p.D.onFn = onBoundary(p.D.location, p.D.shape, global.padding)
    }

    SpecularBounce S
    where InList(S, T) {
        p.S.shape = randElem(d.mirrors)
        -- only show the mirrors involved in a bounce
        P.S.shape.display = "visible"
        p.S.location = (optimized, optimized)
        p.S.onFn = onBoundary(p.S.location, p.S.shape, global.padding)
    }

    -- Draw arrows b/t any 2 consecutive vertices in path
    PathType ray := [A, B]
    with BounceType A, B
    where InList(ray, T) {
        p.ray.shape = Arrow {
            from = p.A.location
            to = p.B.location
            color = p.color
        }

        p.ray.iFn1 = ensure noIntersect(p.ray.shape, d.room)
        p.ray.iFn2 = ensure each_noIntersect(p.ray.shape, d.mirrors)
    }

    -- Draw normals at bounce points
    PathType bounce := [A, B, C]
    with VertexType A, B, C
    where Sublist(bounce, T)  {
        -- No normals for L, E; ray only enters/exits
        p.bounce.normal = Arrow {
            from = p.B.location
            angle = perpendicularTo(p.B.location, p.B.shape)
            length = "small"
            style = "dashed"
        }

    p.bounce.angle_in = Arc {
        from = arrowOf(p.A.location, p.B.location)
        -- replicating ray_in.shape
        to = p.bounce.normal
    }

    p.bounce.angle_out = Arc {
        from = p.bounce.normal
        to = arrowOf(p.B.location, p.C.location)
        -- replicating ray_out.shape
    }
    } and if SpecularBounce B {
        -- Constrain angles for specular bounces
        -- Optimize A, B, C so bounce angles are equal
        ensure equalAngles(p.A.location, p.B.location, p.C.location, p.bounce.normal)
    }
} -- end of "Path p" scope

*/
